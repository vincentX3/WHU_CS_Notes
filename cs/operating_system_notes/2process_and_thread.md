
## 1.引入
> _analogy_ :
> 进程是**动态**的。程序如同作曲家创作的**曲谱**，进程则是**演奏时的音乐**。

`前趋图`：有向无循环图，至少有1个结点无前趋、1个无后继

`顺序执行`: 1.顺序性 2. 封闭性 3. 可再现性
> (I:input C:compute P:output)
> I1->C1->P1->I2->C2->P2...
> `封闭性`: 程序开始后结果不受外界影响
> `可再现性`: 条件相同是程序执行结果一直
 
`并发执行`: 
> 资源共享、次序不定
> I1 -> I2 -> I3...
> ——C1 -> C2 -> C3...
> ————P1 -> P2 -> P3...
> 1. `间断性`: 存在**暂停** 
> 2. `失去封闭性`
> 3. `不可再现性`

👇
#### 并发执行的条件： Bernstein条件
程序A、B各自变量的**读写/写写**无交集。
（否则不同次序写操作导致“失去封闭性”——link.计组流水线**data hazard**）

## 2.进程Process 定义、描述
### 2.1.def_keyword
处理机上、可并行执行的程序运行，系统资源分配的单位
### 2.2.特征
1. 动态性：程序的执行过程。（有生命周期、进程可创建新进程）
2. 并发性
3. 独立性：系统资源分配调度的基本单位
4. 异步性：不同速度推进（Ex. 父子进程执行顺序不确定）
5. 结构性：进程 = 程序段+数据段+进程控制块（PCB）

### 3.进程控制块
PCB：Process Control Block
描述、管理进程的数据结构，进程存在的唯一标志。
通常内容：
- 进程标识符（Ex. 数组下标）
- 进程当前状态（Ex. 执行、就绪……）
- 进程队列指针（方便寻找进程）
- 程序、数据地址
- 进程优先级
- CPU现场保护区、通信信息、家族关系、资源清单

辨析：task&process
> task：Windows、Unix中带接口的进程。不需过度区分。

## 状态与切换
状态切换大多**被动进行**，**运行->其他**可能是主动的
### 基本状态
- 就绪ready ：“就差处理机资源了”
- 执行running
- 阻塞blocking ：不具备运行条件，“给处理机资源也不能运行”
> Unix中ready/running合并为`可运行状态`，通过是否有指向处理机的指针进行区分

### 创建&退出状态
### 挂起状态
EX.单步调试debug
实现：PCB状态值修改、更改指针指向的队列（通过`原语`）

## 4.进程控制
- `OS Kernel`：常驻内存的模块、基本操作——中断、时钟/进程/存储器/设备管理
- 运行状态：`核心态kernel mode`/`用户态user model`
> 区分👉硬件支持，Ex.X86下16位选择符中2位的特权级，区分系统段和用户段
- `原语primitive`：机器指令组合-执行期间**不可分割**
- `进程图`：进程树

### 4.1 创建

引起创建的可能
> 1 调度新作业
> 2 用户登录
> 3 操作系统提供服务
> 4 应用请求

创建原语 procedure:
> 向系统申请PCB → 分配资源 → 初始化PCB →插入**就绪**队列

### 4.2 撤销
策略： 一、只撤销指定标识符 / 二、撤销进程及其子进程
撤销原语 procedure:
> 找PCB → 若在执行，停止 → 处理子孙进程 → 回收资源、PCB
### 4.3 阻塞
**主动发生**
阻塞原语 procedure:
> 终止执行 → 现场保护 → 插入阻塞队列 → 调度新进程执行

### 4.4 唤醒
`非剥夺/可剥夺调度策略`
> 非剥夺指进程持续使用处理机直到其**主动**退出；可剥夺指可终止正在执行的进程，进行其他调度
唤醒原语 procedure:
> 从等待队列移除进程 → 插入就绪队列 → 检查优先级（比当前执行进程优先级高，则**设置调度标志**
### 4.5 挂起/激活
人为的

## 5. 进程组织
“管理PCB的物理结构”
方式：
1 线性
> - 连续内存中
> - 设置0号进程做“终止哨兵”  

2 链表
> 同状态的进程组成链表队列

3 索引
👆进程常综合线性、链表方式管理（索引常用于`文件管理`）

## 6. 线程thread
#### background
- 进程切换开销大（现场保护等）👉希望减少进程切换的时空开销
- 出现多核处理机
### 6.1 多线程特点
- 只拥有很少资源（程序计数器、寄存器、栈）
- 共享进程资源
- 驻留相同地址空间
//Linux中线程、进程的数据结构相同
### 6.2 实现
analogy:
> 计划经济，每个家庭为一个进程，家庭成员为线程，口粮为处理机资源
> 内核级——口粮配给按照人头数分配，人口多就给的多
> 用户级——每个家庭定量配给口粮，不管人口(线程)多少
- kernel-level thread
> 依赖OS内核
- user-level thread
> 依靠编程
- 两者混合