1.调度的层次
1. 作业调度（高级，长程，宏观）
> 外存到内存，分配内存、IO设备等资源并建立进程
> 频率低
2. 进程调度（低级，短程，微观）
> 处理机分配
> 频率高
3. 交换调度（中程）
> 提高内存利用率，系统吞吐量
> 将内存中暂时不用的信息移到外存，需要的信息读入内存（虚存的实现）

2层调度方法可不同，但不应冲突
不同系统分层不同，甚至存在多级调度：（线程）-进程-（交换/中程）-作业

### 性能评价
多，各有侧重
- CPU利用率
- 系统吞吐量throughput
- 周转时间turnaround time,$T_i=T_{ei}-T_{si}$ (e：完成，s：提交)
    > 平均周转时间
    带权周转时间(周转时间÷实际运行时间)👈比值，**无量纲**
    平均带权周转时间
- 响应时间response time 

## 2.作业调度
### 状态与转换
1. 提交
2. 后备
3. 运行
4. 完成

### JCB作业控制块
包括但不限于：

1. 资源要求 Ex. 最迟完成时间
2. 资源使用情况
3. 作业的控制方式、类型、优先级 
> 联机/脱机，终端/批量
4. 作业名、作业状态

## 3.进程调度
### 功能
1. 记录
2. 选择进程
3. 处理机分配、回收

### 引起调度原因
review：进程状态的控制👉依靠*原语*（一组硬件指令）

1. 处理机空闲
2. 运行的进程阻塞
3. 时间片用完
4. 高优先级进程就绪（在*剥夺调度*下）
5. 进程进入空的就绪队列

### 调度方式
1. 抢占 preemptive

    原则：优先权/时间片
> Ex.分时系统、实时系统
> 响应及时，开销相对大（进程切换）
> 状态转换：执行←→就绪
2. 非抢占 nonpreemptive
> 开销相对小
> 状态转换：执行←→等待

## 4.调度算法
### 4.1 First-come,first-served 先来先服务
实现简单开销小
> data structure：队列，头尾指针，无须排序、查找

不利于短作业及I/O繁忙型作业，可能


### 4.2 短作业优先
选择**估计**运行时间最短的作业/进程
but，估计**难**且**不准**
> 对长作业不利，饥饿

**抢占式：最短剩余时间优先**

### 4.3 优先级
1. 静态优先级

    划分依据：
    1. 进程类型： 系统/用户
    2. 资源要求
    3. 用户要求 
    
2. 动态优先级
    1. 占有CPU时间长短
    2. 就绪进程等待时间长
    
### 4.4 时间片
本质：动态优先级+先进先出
时间片大小很关键：

1. 系统对响应时间要求
> 响应时间=时间片*进程数
2. 就绪队列进程数目
3. 系统处理能力

↑ 对重视IO进程不公平
提出: **虚拟时间片轮转算法**
![](/assets/4time_slice.png)

### 4.5 高响应比优先调度
定义响应比：

`响应比=1+作业等待时间/估计运行时间`

问题：运行时间难准确估计

### 4.6 多级队列调度
多个子队列，每个子队列一种调度算法

### 4.7 多级反馈队列调度
![](/images/4multi_sequences.png)

## 5 死锁
1. 原因
    1. 竞争资源
    2. 推进顺序不当
    > Ex.
    ![](/images/4lock_example.png)
2. 必要条件
    1. `互斥`：资源排他
    2. `不剥夺`：进程获得资源后只能由该进程自己释放
    3. `请求和保持`：“尸位素餐”，即进程等待分配新资源时继续占有已分配资源
    4. `循环等待`：存在*循环等待链*
    > p1 request a -> p2 request b -> p1 request b -> p2 request a
    
    - **思考**：
    能否通过否定必要条件，解决死锁问题？见4.5.4
    
3. 基本方法

    1.忽略死锁（`鸵鸟算法`👈工程思维：忽略死锁，尽量降低死锁频率）
    2/3/4（废话来的）：预防/避免/检测及解除
    
### 4. 预防死锁
破坏必要条件

1. 破坏`互斥`？
不现实。大多进程要求排他使用资源，否则出现如“同时读写”问题。

2. 破坏`不剥夺`？
允许剥夺资源。
问题：对进程的现场保护？剥夺哪个进程的资源？等
适合：状态易于保存和恢复的资源
不适合：Ex.
 p1使用打印机打印到一半，p2被剥夺了打印机。已经打出来的半份资料怎么办

3. 破坏`请求和保持`？
    **静态资源分配法**
    👆“我全都要！”，即进程运行前保证获得全部资源
    pros：
    简单安全
    cons：
    **资源利用率低**
4. 破坏`循环等待`？

    **有序资源分配**
    要求：
    资源序号相对稳定
    pros：
    资源利用率高，吞吐量大
    cons：
    使用资源的**顺序**限制程序员编程
    
### 5.避免死锁
#### 1. 安全与不安全状态 
#### 2. 银行家算法
- 要求

    进程进入系统，必须说明其所需每类资源的最大数量
- 数据结构

``` C
Available:  可利用资源向量，每个元素代表一类资源空闲资源数目，(m,1)
Max：       最大需求矩阵，每个进程对各类资源的最大需求数目，(n,m)
Allocation: 分配矩阵，每个进程已获得各类资源的数目，(n,m)
Need:       需求矩阵，每个进程还需要的各类资源数，(n,m)
```
所以有关系
```math
Need_i=Max_i-Allocation_i
```

- 实现思想

    设`Request_i`为进程Pi的请求向量，`Request_i(j)=k`表示Pi请求分配j类资源k个，then执行以下检查
    1. if Request_i ≤ Need_i，转2 （“**戒贪**”）
    2. if Request_i ≤ Available_i，转3；否则**等待**（“**戒躁**”）
    3. 系统尝试分配Request_i的资源，并修改：
``` C
Available ＝ Available－Requesti ；
Allocationi ＝ Allocationi ＋ Requesti ；
Needi ＝ Needi－ Requesti ；
```
    final：执行**安全性算法**
    > 安全则正式分配；否则试分配作废，Pi等待
    
    
### 6.死锁检测与解除
1. `资源分配图`

    有向图。结点分为2个互斥子集：`进程结点`/`资源结点`
    {pi,rj}为资源请求边；{rj,pi}为资源分配边
    无环无死锁，有环不一定死锁

2. 死锁定理

3. 检测

4. 解除    
    1. 资源剥夺
    2. 撤销进程
    3. now，回退法：进程运行时记录状态，若发生死锁，回退至之前记录的某个状态
    
    
---
## 杂

- 死锁是不安全状态的**子集**
