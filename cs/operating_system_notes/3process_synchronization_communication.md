# 3. 进程同步与通信
## 同步与互斥
### 概念
`直接制约关系`：两个进程在某些点上**交换信息**。👈**同步**
`间接制约关系`：两个进程**竞争互斥**的资源。👈**互斥**

#### 临界资源&临界区
`临界资源`：互斥的资源，同一时间只有一个进程能够访问。
`临界区`：访问临界资源的代码段
```
|进入区|
↓
|临界区|
↓
|退出区|
↓
|剩余区|
```
进入临界区的进程应该满足：
1. 空闲让进
2. 忙则等待
3. 有限等待（不能死锁）
4. 让权等待（转换为阻塞状态）
## 互斥的实现
对**不满足Bernstein条件**的进程进行约束。
### sofeware
算法*4
使用数组，全局变量进行进入条件的监测和修改。效果差。
### hardware
**思想**：指令实现标志的检查和修改。保证检查、修改操作不被打断。
#### 硬件指令方法
👇硬件指令，用C描述
- TS(test and set)
> “关锁”。 返回**原**资源状态，并将该资源锁定。
> 若原资源被占用，则等待，直到被占用进程解锁；未被占用则当前进程占用并关锁。
``` C
boolean TS(boolean *lock)
{
   boolean old;
   old=*lock;
   *lock=true;
   return old;
}
/*---------------------*/
/*---进程互斥实现伪码---*/
...
while TS(&lock);
临界区代码;
lock=false;
剩余区代码;
...
```
- Swap
> lock-共享Boolean；key-每个进程的局部Boolean
`lock`表示门（临界资源）是否被锁（被占用），`key`表示开门钥匙（进程就绪）
通过Swap交换lock、key状态进行

- 锁机制

👆硬件指令，都未实现**让权等待**；随机选择执行进程，可能导致**饥饿**

## 信号量semaphore←资源实体的抽象
### 基本概念

``` 
___|   |___
___  *  ___
   |   |

//红绿灯，十字路口为临界资源
//PV操作即十字路口的红绿灯
//进程：小汽车~

```

(count,queue)
> `count`：整型——没半个使用的打印机。初值非负——资源顶多没有，不可能欠着
> > "c>=0"可用资源数目
> > "c<0"因请求该资源而阻塞进程数目
> > 取值范围，n个进程：[-(n-1), 1]
> `queue`：初始为空的队列，”信号灯“

**P/V 操作**
👆荷兰语 探查/增加， 老美用wait/signal
唯一能改变信号量（初始化后）的操作——不可直接对信号量进行加减
> 不像此前算法，使用while进行监测。PV实现了`让权等待`
> C语言中`wait()`调用PV操作
> 辨证：程序员负担增重，编程考虑PV操作

### 互斥
### 同步
实现前趋关系
- 法1：边 
> 边数=信号量的数目
> 前趋结点的边P操作，后继结点的边V操作
- 法2：结点（出入度关系）

## 进程关系👉经典问题
> 如何发现进程的制约关系？

编程:信号量P操作：一般先**同步**再**互斥**

- 生产者-消费者问题
> 即：**有界缓冲池**问题
> 互斥问题：in,out 指针同时只能被唯一的生产者、消费者访问。（相同缓冲区只能有1个生产者写入或消费者读出👉**时、空的互斥**）
> 同步问题：“产能过剩（库存积压）/产能不足（小米饥饿营销）” 
↑↑↑
信号量机制处理：
```
//Pseudo code
semaphore full=0;   //同步变量，已写缓冲区的数目
semaphore empty=n;  //同步变量，空缓冲区的数目 
semaphore mutex=1;  //互斥变量，实现进程间操作互斥 
main()
{   
   cobegin
      producer();
      consumer();
   coend 
}
producer()
{
   while(Ture)
   {
      produce a product;   
      p(empty);
      p(mutex);
      deliver product to buffer;
      v(mutex);
      v(full);
   }
}
consumer()
{
   while(True)
   {
      p(full);
      p(mutex);
      fetch a product;
      v(mutex);
      v(empty);
      consume a product;
   }
}
```
caution!!：`P`操作次序不能颠倒，否则**死锁**。

- 读者-写者
进程对共享资源的读写操作矛盾，互斥问题
> 类比组成原理*数据冒险*，是WR间的**非对称问题**。
> 算法分类：读优先/写优先
*读优先算法* 思路：引入**读进程计数器**，关注**第一个**与**最后一个**读进程。
> > analogy：同学进教室。第一个人开门（确保没有写进程执行），最后一个人锁门（唤醒写进程）
```
//Pseudo code
semaphore rmutex=1;
semaphore wmutex=1;
int readcount=0; //读进程计数器
main()
{   
   cobegin
      reader();
      writer();
   coend 
}
```

   > 👆如果持续有读进程发生，则写进程处于*饥饿*状态（无法执行） 
   
- 哲学家进餐
> 如何处理**对多个共享资源的访问**，互斥问题
> 哲学家只干两件事，思考（*剩余区* 代码段）与进餐（*临界区* 代码段），这帮哲学家是亚洲人，坐圆桌子（*环型*），要用筷子，拿齐一对才开始吃——不吃手抓饭。 
> 
> 暴力解：大家都先拿左筷子，再右筷子。拿齐就开始吃。
存在死锁问题👉资源不足
↓↓↓
解决思路：
> 1. 加资源（作为操作系统，无法强求用户添资源。且资源不能无上限添加；盲目增加资源，利用率低）
> 2. 对进程增添限制条件
> > 1. 减少并发进程道数，Ex最多4人进餐(增加全局信号量 `eatNumber=4`）
> > 2. **调整P操作次序**，EX奇数哲学家先拿左筷子，偶数哲学家先拿右筷子


- 睡眠理发师
> 互斥+同步，1 server + n customers (customers<=n)
> 
> 与上3问题明显区别:customers**不循环**执行
> - 初值的理解：早上开业时，理发师与顾客谁单独到达，都无事可做，只能等待对方的到达。
> 
```
semaphore customers=0; //等待顾客数
semaphore barbers=0; //理发师可以提供剪发服务的数量
semaphore mutex=1;
int waiting=0; //信号量customers副本。
#define MAX_WAITING_NUMEBER N;
main()
{
cobegin
   barber();
   customer();
coend
}
barber()
{
   while(True)
   {
      p(customers); //有无排队的顾客，无则休息（阻塞）
      p(mutex);
      waiting--;
      v(barbers);
      v(mutex);
      cut_hair();
   }
}
customer()
{
   p(mutex);
   if (waiting<MAX_WAITING_NUMEBER) //进店看看有没有空位
   {
      waiting++; //坐着等
      v(customers); //招呼理发师干活
      v(mutex);
      p(barbers); //看看理发师忙不忙
      get_hair_cut();
   }
   else v(mutex); //人满，撤了
}
```

### 信号量集机制
由来：
> *记录型信号量* 解决了**单个**资源互斥访问问题。但面对**多个**资源（e.g.哲学家进餐）的互斥访问时，编程困难，容易导致死锁。

#### 1.AND型
实质：把需要的全部资源抽象为**1个资源实体**。
即，要么分配全部所需资源给进程，要么阻塞。

#### 2.一般信号量集机制
**泛化**
```
SP{
   S1;//S1信号量
   t1;//S1的临界值，S1<t1则不分配资源
   d1;//请求的资源数量
   ...
   Sn;tn;dn;
}
```
特殊情况*3
1. `SP(S,d,d)`
2. `SP(S,1,1)`
3. `SP(S,1,0)`

## 管程
#### 1. BG
信号量分布在程序中→编程、管理难，导致bug多
#### 2. 管程的理解
*def* ：定义了一个数据结构和能为并发进程执行的一组操作。（且对管程内部数据设置初值）
```C
Monitor monitor_name;
variable declarations; //共享变量声明
P1(...){...}
P2(...){...}
.
.
.
Pn(...){...)
{
   initialization code;
}
```
👆👆👆 这不就是个**object**嘛
*实现*：交由编译器编译
#### 3. 对经典问题的解决

## 通信
#### 1. 发展过程
单道时期（无通信） -> 信号机制（低级通信，少量控制信息） -> 管道通讯pipe（大量信息交换，一对一） -> Unix system V通信机制(计算机网络也广泛使用）
#### 2. 类型
1. 共享存储器系统
   1. why
   提升空间利用率/减少版本冲突/**进程通讯**
   2. 实现
   申请缓冲区并将其地址附接到多个进程的地址空间中
2. 消息传递系统
   1. 消息缓冲通信
      > PCB增加：消息队列头指针，消息数目信号量，互斥读取消息信号量
   2. 信箱通信 
3. 管道通信系统
   1. 分类：命名/匿名
   2. 命名管道——全部进程可访问
   3. 匿名管道——临时文件，同家族进程可访问

---
### 补充
- 单处理机：进程间为并发但无**并行关系**
- 通道：大型机、多用户计算机，中专门处理IO的处理机

